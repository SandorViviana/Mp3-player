$version 12.05

// This is the root component of the entire GUI application.
$rect <-270,-179,-70,-139>
class Application : Core::Root
{
  $rect <820,10,1020,50>
  inherited property Bounds = <0,0,800,480>;

  // To do:
  // 
  // - Adjust the visible size of your application (the thick blue border). It should \
  // correspond to the size of your target display.
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widgets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,500,790,730>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Application::PlayerDialog PlayerDialog
  {
    preset Bounds = <0,0,801,480>;
  }
}

$rect <789,-190,989,-150>
$output false
resource Resources::Font TitleFont
{
  attr fontname FontName = Lucida Sans Typewriter;
  attr fontheight Height = 32;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-290,-50,-90,-10>
class PlayerDialog : Core::Group
{
  $rect <900,-10,1100,30>
  inherited property Bounds = <0,0,800,480>;

  $rect <900,110,1100,150>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <900,70,1100,110>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Bounds = <0,0,800,489>;
    preset Bitmap = Application::Background;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider Playback
  {
    preset Bounds = <117,387,582,436>;
    preset OnUpdate = null;
    preset OnChange = OnSliderChange;
    preset MaxValue = 100;
    preset CurrentValue = 0;
    preset Appearance = Application::HorizontalSliderConfig;
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Bounds = <368,60,788,175>;
    preset AutoSize = false;
    preset WrapText = true;
    preset String = "Title";
    preset Font = Application::TitleFont;
  }

  $rect <20,20,160,60>
  object Views::Text Artist
  {
    preset Bounds = <379,157,784,187>;
    preset String = "Artist";
    preset Font = Application::Font;
  }

  $rect <20,20,160,60>
  object Views::Text CurrentTime
  {
    preset Bounds = <57,395,118,425>;
    preset String = "0:00";
    preset Font = Application::TimeFont;
  }

  $rect <20,20,160,60>
  object Views::Text Duration
  {
    preset Bounds = <582,395,645,425>;
    preset String = "10:59";
    preset Font = Application::TimeFont;
  }

  $rect <20,20,160,60>
  object Views::Image ToTheQueue
  {
    preset Bounds = <375,436,425,486>;
    preset FrameNumber = 1;
    preset Bitmap = Resources::NavigationIconsLarge;
  }

  $rect <900,150,1100,190>
  inherited method Init()
  {
    deviceRef = Application::Device;

    attachobserver OnTimeUpdate, ^deviceRef.CurrentTime;
    attachobserver OnTimeUpdate, ^deviceRef.Duration;
    attachobserver OnTimeUpdate, null, 123;
    attachobserver OnTimeUpdate, null, 124;
    postsignal OnTimeUpdate;




  }

  // Conceptual equivalent to TimeUpdate
  $rect <1133,160,1330,200>
  slot OnSliderChange
  {
    deviceRef.UpdateTimeFromSlider(Playback.CurrentValue);
  }

  $rect <890,379,1090,419>
  $output true
  var Application::DeviceClass deviceRef = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PlayPause
  {
    preset Bounds = <298,337,353,387>;
    preset Visible = true;
    preset OnRelease = OnPlayPause;
    preset OnPress = PlayPausedPressed;
    preset Icon = Application::PlayIcon;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Loop
  {
    preset Bounds = <344,335,405,385>;
    preset OnRelease = OnLoop;
    preset Icon = Application::LoopIcon;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <-8,790,192,830>
  $output true
  slot OnLoop
  {
    deviceRef.LoopTrack();
    if(Application::Device.Loop)
        Loop.Icon=Application::LoopPressedIcon;
    else   Loop.Icon=Application::LoopIcon;


  }

  $rect <1123,200,1323,240>
  slot OnTimeUpdate
  {
    EnableDisableButtons();
    if(Playback.MaxValue != deviceRef.Duration ){
    Playback.MaxValue=deviceRef.Duration;
    trace "The maximum value of the slider is ", Playback.MaxValue;
    }
    trace "The current value  of the slider is ", Playback.CurrentValue;
    Playback.CurrentValue=deviceRef.CurrentTime;
    Duration.String=deviceRef.IntToTimeString(deviceRef.Duration);
    CurrentTime.String=deviceRef.IntToTimeString(deviceRef.CurrentTime);
    if(Playback.CurrentValue==Playback.MaxValue && Playback.CurrentValue!=0)
     if(!Application::Device.Loop)
    {    if(Application::Device.CanGoNext())
                 OnNextMethod();
                 
        else   
        { 
          OnEnded();
        }
     }

    Artist.String=Application::Device.Artist;
    Title.String=Application::Device.TitleOfTrack;
  }

  $rect <252,670,452,710>
  slot PlayPausedPressed
  {
    switch(Application::Device.PlayerState)
    {

          case Application::State.Playing:
                      PlayPause.Icon=Application::PausePressedIcon;
          default:
                      PlayPause.Icon=Application::PlayPressedIcon;
    }
  }

  $rect <1,670,202,710>
  slot OnPlayPause
  {
    switch(Application::Device.PlayerState)
    {
        case Application::State.Playing:
        
            OnPause();
                 
        case Application::State.Paused:
        
              OnPlay();
        case Application::State.CanPlay:
              
              OnPlay();
        case Application::State.Ended:
              {
                  Application::Device.UpdateCurrentTime(0);
                  OnPlay();
              }
        default:OnPlay();

    }

  }

  $rect <972,670,1172,710>
  method void OnPlay()
  {
    deviceRef.Play();
    signal VinylView.AngleEffect.StartEffect;
    PlayPause.Icon=Application::PauseIcon;
    Application::Device.UpdatePlayerState( Application::State.Playing );
  }

  $rect <972,720,1172,760>
  method void OnPause()
  {
    deviceRef.Pause();
    signal VinylView.AngleEffect.StopEffect;
    PlayPause.Icon=Application::PlayIcon;
    Application::Device.UpdatePlayerState( Application::State.Paused );
  }

  $rect <972,769,1172,809>
  method void OnEnded()
  {
    Application::Device.CurrentFileIndex=0;

    //Playback.CurrentValue=0;
    Application::Device.UpdatePlayerState( Application::State.Ended);
    PlayPause.Icon=Application::PlayIcon;
    signal VinylView.AngleEffect.StopEffect;
  }

  $rect <20,20,160,60>
  object Application::VinylView VinylView
  {
    preset Bounds = <-5,-1,474,349>;
  }

  $rect <1120,259,1320,299>
  slot OnOpenQueue
  {
    Owner.SwitchToDialog( new Application::QueueView, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );


  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler OpenQueue
  {
    preset Bounds = <7,432,800,486>;
    preset OnTop = OnOpenQueue;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PreviousButton
  {
    preset Bounds = <249,338,299,387>;
    preset OnRelease = OnPrevious;
    preset OnPress = PreviousPressed;
    preset Icon = Application::PreviousIcon;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton NextButton
  {
    preset Bounds = <402,341,452,386>;
    preset OnRelease = OnNext;
    preset OnPress = NextPressed;
    preset Icon = Application::NextIcon;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <-8,889,192,929>
  slot OnPrevious
  {
    Application::Device.CurrentFileIndex-=1;
    if(Application::Device.PlayerState==Application::State.Playing)
            OnPlay();

  }

  $rect <-8,960,192,1000>
  slot OnNext
  {
    OnNextMethod();
  }

  $rect <252,889,452,929>
  slot PreviousPressed
  {
    PreviousButton.Icon=Application::PreviousPressedIcon;
  }

  $rect <252,960,452,1000>
  slot NextPressed
  {
    NextButton.Icon=Application::NextPressedIcon;
  }

  $rect <971,960,1171,1000>
  method void OnNextMethod()
  {
    Application::Device.CurrentFileIndex+=1;
    if(Application::Device.PlayerState==Application::State.Playing)
            OnPlay();


  }

  $rect <701,880,901,920>
  method void DisablePrevious()
  {
     PreviousButton.Enabled=false;
     PreviousButton.Icon=Application::PreviousDisabledIcon;
  }

  $rect <691,960,891,1000>
  method void DisableNext()
  {
     NextButton.Icon=Application::NextDisabledIcon;
     NextButton.Enabled=false;
  }

  $rect <492,880,692,920>
  method void EnablePrevious()
  {
    PreviousButton.Enabled=true;
    PreviousButton.Icon=Application::PreviousIcon;
  }

  $rect <491,960,691,1000>
  method void EnableNext()
  {
     NextButton.Enabled=true;
     NextButton.Icon=Application::NextIcon;
  }

  $rect <581,820,781,860>
  method void EnableDisableButtons()
  {
    if(Application::Device.CanGoBefore())
          EnablePrevious();
    else DisablePrevious();
    if(Application::Device.CanGoNext())
          EnableNext();
    else DisableNext();
  }

  // Player controls
  note group Note
  {
    attr Bounds = <-38,531,1261,1040>;
  }

  // Slot methods
  note group Note1
  {
    attr Bounds = <-19,630,221,1020>;
  }

  // Pressed buttons
  note group Note2
  {
    attr Bounds = <240,630,461,1020>;
  }

  // Enable/Disable
  note group Note3
  {
    attr Bounds = <491,754,920,1020>;
  }

  // State changers
  note group Note4
  {
    attr Bounds = <941,629,1242,826>;
  }

  // Additional methods
  note group Note5
  {
    attr Bounds = <941,889,1240,1020>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Background
  $member Playback
  $member Title
  $member Artist
  $member CurrentTime
  $member Duration
  $member ToTheQueue
  $member OnSliderChange
  $member deviceRef
  $member PlayPause
  $member Loop
  $member OnLoop
  $member OnTimeUpdate
  $member PlayPausedPressed
  $member OnPlayPause
  $member OnPlay
  $member OnPause
  $member OnEnded
  $member VinylView
  $member OnOpenQueue
  $member OpenQueue
  $member PreviousButton
  $member NextButton
  $member OnPrevious
  $member OnNext
  $member PreviousPressed
  $member NextPressed
  $member OnNextMethod
  $member DisablePrevious
  $member DisableNext
  $member EnablePrevious
  $member EnableNext
  $member EnableDisableButtons
  $member Note
  $member Note1
  $member Note2
  $member Note3
  $member Note4
  $member Note5

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder Init 2
}

$rect <-290,-10,-90,30>
$output false
class QueueView : Core::Group
{
  $rect <861,0,1050,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <50,550,250,590>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <50,510,250,550>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-6,-10,808,480>;
    preset Color = #121516FF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList Queue
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <17,127,779,372>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = ScrollHandler;
    preset ItemHeight = 50;
    preset NoOfItems = 8;
    preset ItemClass = Application::QueueItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <450,510,680,550>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = Queue.Item;
    var Application::QueueItem itemView = (Application::QueueItem)Queue.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.Title.String = Application::Device.GetTitleById(itemNo);
    itemView.Artist.String=Application::Device.GetArtistById(itemNo);
    itemView.Source=Application::Device.GetSongById( itemNo );
    if(itemView.Source==Application::Device.Src)
         {   Queue.SelectedItem=itemNo;
             Queue.EnsureVisible( itemNo, true, null, null );
         }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = Queue.ViewSize;

     //Queue.NoOfItems=Application::Device.GetSizeOfList();

  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <355,-2,405,48>;
    preset FrameNumber = 0;
    preset Bitmap = Resources::NavigationIconsLarge;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler BackToPlayer
  {
    preset Bounds = <3,-2,797,51>;
    preset OnBottom = OnReturnToPlayer;
  }

  $rect <859,202,1059,242>
  slot OnReturnToPlayer
  {
    //this.Visible=false;
    Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );


  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler ScrollHandler
  {
    preset Bounds = <18,126,781,370>;
    preset SnapNext = <0,50>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SelectHandler
  {
    preset Point4 = <19,131>;
    preset Point3 = <782,130>;
    preset Point2 = <784,370>;
    preset Point1 = <19,370>;
    preset OnRelease = OnSelect;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <859,240,1059,280>
  slot OnSelect
  {
    if ( SelectHandler.AutoDeflected )
     { 
     return;
     }

    var int32 itemNo = Queue.GetItemAtPosition( SelectHandler.CurrentPos );


    if ( itemNo >= 0 )
    {

      Queue.SelectedItem = itemNo;
      Application::Device.CurrentFileIndex=itemNo;
      Queue.EnsureVisible( itemNo, true, null, null );
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
       if(Application::Device.PlayerState==Application::State.Playing) 
              Application::Device.Play();


    }
  }
}

$rect <340,-190,540,-150>
$output false
resource Resources::Bitmap Background
{
  attr bitmapfile FileName = .\Images and Icons\background.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,-150,540,-110>
$output false
resource Resources::Bitmap GenericVinyl
{
  attr bitmapfile FileName = .\Images and Icons\genericVinyl.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <789,-150,989,-110>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Arial;
  attr fontheight Height = 24;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <789,-110,989,-70>
$output false
resource Resources::Font TimeFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 17;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <339,-110,539,-70>
$output false
resource Resources::Bitmap Thumb
{
  attr bitmapfile FileName = .\Images and Icons\thumb.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This object contains configuration information for a slider widget.
$rect <360,219,650,259>
$output false
autoobject WidgetSet::HorizontalSliderConfig HorizontalSliderConfig
{
  preset ThumbUpdateAtTouch = true;
  preset ThumbMarginRight = 0;
  preset ThumbMarginLeft = 0;
  preset ThumbFrameActive = 0;
  preset ThumbFrameFocused = 0;
  preset ThumbFrameDisabled = 0;
  preset ThumbFrameDefault = 0;
  preset ThumbActive = WidgetSet::VerticalScrollbarThumbSmall;
  preset ThumbFocused = Application::Thumb;
  preset ThumbDefault = Application::Thumb;
  preset TrackRightTintActive = #F5F5F593;
  preset TrackRightTintFocused = #F5F5F593;
  preset TrackRightTintDefault = #F5F5F593;
  preset TrackRightFrameActive = 0;
  preset TrackRightFrameFocused = 0;
  preset TrackRightFrameDisabled = 0;
  preset TrackRightFrameDefault = 0;
  preset TrackRightActive = WidgetSet::MiniHorizontalScrollbarTrackSmall;
  preset TrackRightFocused = WidgetSet::MiniHorizontalScrollbarTrackSmall;
  preset TrackRightDefault = WidgetSet::HorizontalSliderTrackSmall;
  preset TrackLeftTintActive = #FFFFFFFF;
  preset TrackLeftTintFocused = #FFFFFFFF;
  preset TrackLeftTintDefault = #FFFFFFFF;
  preset TrackLeftFrameActive = 0;
  preset TrackLeftFrameFocused = 0;
  preset TrackLeftFrameDisabled = 0;
  preset TrackLeftFrameDefault = 0;
  preset TrackLeftActive = WidgetSet::HorizontalSliderTrackSmall;
  preset TrackLeftFocused = WidgetSet::MiniHorizontalScrollbarTrackSmall;
  preset TrackLeftDefault = WidgetSet::HorizontalSliderTrackSmall;
}

$rect <-69,150,131,190>
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Application::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
      postsignal InitSlot;

  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <540,379,740,419>
  property Application::State PlayerState = Application::State.CanPlay;

  $rect <540,419,740,459>
  onset PlayerState
  {
    // The value doesn't change - nothing to do.
    if ( pure PlayerState == value )
      return;

    // Remember the property's new value.
    pure PlayerState = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <530,459,730,499>
  onget PlayerState
  {
    return pure PlayerState;
  }

  // It should be deduced from the mp3 file tags. It can be omitted in the device \
  // class
  $rect <781,59,981,99>
  property string TitleOfTrack = "Title";

  $rect <781,99,981,139>
  onset TitleOfTrack
  {
    // The value doesn't change - nothing to do.
    if ( pure TitleOfTrack == value )
      return;

    // Remember the property's new value.
    pure TitleOfTrack = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <781,139,981,179>
  onget TitleOfTrack
  {
    return pure TitleOfTrack;
  }

  // See TitleOfTheTrack
  $rect <550,59,750,99>
  property string Artist = "Artist";

  $rect <550,99,750,139>
  onset Artist
  {
    // The value doesn't change - nothing to do.
    if ( pure Artist == value )
      return;

    // Remember the property's new value.
    pure Artist = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <550,139,750,179>
  onget Artist
  {
    return pure Artist;
  }

  $rect <30,540,230,580>
  method string IntToTimeString( arg int32 aArg1 )
  {
    //var string timeString="";
    //var int32 hours=aArg1/3600;
    //var int32 minutes=aArg1/60;
    //var int32 seconds=aArg1%60;
    //if(hours>0)
    //{
    //timeString+=(string)hours+":";
    //}
    //return timeString+(string)minutes+":"+(string)seconds;

     $if $platform == Web.*.*
          native
       {
     return EmWiPlayer.formatTime(aArg1);
       }  
     $endif
     return "0:00";
  }

  // the current playback position in seconds
  $rect <300,200,500,240>
  $output true
  property int32 CurrentTime;

  // Equivalent of the event TimeUpdate
  $rect <300,240,500,280>
  onset CurrentTime
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentTime == value )
      return;

    // Remember the property's new value.
    pure CurrentTime = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <300,280,500,320>
  onget CurrentTime
  {
    return pure CurrentTime;
  }

  $rect <530,200,730,240>
  $output true
  property int32 Duration;

  $rect <530,240,730,280>
  $output true
  onset Duration
  {
    // The value doesn't change - nothing to do.
    if ( pure Duration == value )
      return;

    // Remember the property's new value.
    pure Duration = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <530,280,730,320>
  onget Duration
  {
    return pure Duration;
  }

  $rect <290,390,490,430>
  $output true
  property bool Loop = false;

  $rect <290,430,490,470>
  onset Loop
  {
    // The value doesn't change - nothing to do.
    if ( pure Loop == value )
      return;

    // Remember the property's new value.
    pure Loop = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <290,470,490,510>
  onget Loop
  {
    return pure Loop;
  }

  // Source of the file
  $rect <300,59,500,99>
  property string Src = "";

  $rect <300,99,500,139>
  onset Src
  {
    // The value doesn't change - nothing to do.
    if ( pure Src == value )
      return;

    // Remember the property's new value.
    pure Src = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.

    $if $platform == Web.*.*
       native
       {
             EmWiPlayer.setSource(value);   
       } 
    $endif

  }

  $rect <300,139,500,179>
  onget Src
  {
    return pure Src;
  }

  $rect <30,310,230,350>
  $output true
  method void Play()
  {
    $if $platform == Web.*.*
       native
       {
       EmWiPlayer.play();
       } 
    $endif

    //this.UpdatePlayerState( Application::State.Playing);              
  }

  $rect <30,350,230,390>
  $output true
  method void Pause()
  {
    $if $platform == Web.*.*
       native
       {
       EmWiPlayer.pause();
       //var audiotrack= document.getElementById("audio");
       // audiotrack.pause();
       // console.log("pause");
       } 
    $endif
    //vezi Play()
    this.UpdatePlayerState( Application::State.Paused);
  }

  $rect <30,390,230,430>
  $output true
  method void LoopTrack()
  {
    $if $platform == Web.*.*
       native
       {
     EmWiPlayer.loop();
       }   
    $endif 

    this.Loop=!this.Loop;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <530,499,730,539>
  $output true
  method void UpdatePlayerState( arg Application::State aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure PlayerState )
    {
      // Remember the new value in the internal memory of the property.
      pure PlayerState = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^PlayerState;
    }
  }

  $rect <290,320,490,360>
  $output true
  method void UpdateCurrentTime( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure CurrentTime )
    {
      trace "update CurrentTime from ", pure CurrentTime, " to ", aNewValue;
      // Remember the new value in the internal memory of the property.
      pure CurrentTime = aNewValue;
              
      // Notify all associated property observers.
      notifyobservers ^CurrentTime;
      notifyobservers null, 123;
      }
     
  }

  $rect <30,430,230,470>
  $output true
  method void UpdateTimeFromSlider( arg int32 aArg1 )
  {
    this.UpdateCurrentTime(aArg1);
    $if $platform == Web.*.*
       native
       {
       
      EmWiPlayer.seeking(aArg1);
        }
       
    $endif  

  }

  $rect <530,320,730,360>
  $output true
  method void UpdateDuration( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Duration )
    {
      trace "update Duration from ", pure Duration, " to ", aNewValue;
      // Remember the new value in the internal memory of the property.
      pure Duration = aNewValue;
              
      // Notify all associated property observers.
      notifyobservers ^Duration;
      notifyobservers null, 124;
      }
     
  }

  $rect <30,200,230,240>
  slot InitSlot
  {
    $if !$prototyper
      
      var object thisObject = this;  


      native ( thisObject )
      {
           EmWiPlayer.initialize();
      
      }
      CurrentFileIndex=0;
    $endif

  }

  $rect <1180,279,1380,319>
  property int32 CurrentFileIndex = -1;

  $rect <1180,319,1380,359>
  onset CurrentFileIndex
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentFileIndex == value )
      return;

    // Remember the property's new value.
    pure CurrentFileIndex = value;

    TitleOfTrack=GetTitleById(CurrentFileIndex );
    Artist=GetArtistById( CurrentFileIndex );
    this.Src=GetSongById(CurrentFileIndex);


  }

  $rect <1180,359,1380,399>
  onget CurrentFileIndex
  {
    return pure CurrentFileIndex;
  }

  $rect <1179,61,1379,101>
  method string GetTitleById( arg int32 aArg1 )
  {
    $if $platform == Web.*.*
       native
       {
             return SongList.getTitleByIndex(aArg1);   
       } 
    $endif
    return "";
  }

  $rect <1179,101,1379,141>
  method string GetArtistById( arg int32 aArg1 )
  {
    $if $platform == Web.*.*
       native
       {
             return SongList.getArtistByIndex(aArg1);   
       } 
    $endif
    return ""; 
  }

  // Playlist Management
  note group Note
  {
    attr Bounds = <1150,240,1410,599>;
  }

  $rect <1179,150,1379,190>
  method string GetSongById( arg int32 aArg1 )
  {
    $if $platform == Web.*.*
       native
       {
             return SongList.getSongAtIndex(aArg1);   
       } 
    $endif
    return "";
  }

  $rect <1180,420,1380,460>
  method bool CanGoBefore()
  {
    if(this.CurrentFileIndex==0)
        return false;
    return true;
  }

  $rect <1181,464,1381,504>
  method bool CanGoNext()
  {
    return !(this.CurrentFileIndex==GetSizeOfList()-1);
  }

  $rect <1180,530,1380,570>
  method int32 GetSizeOfList()
  {
    $if $platform == Web.*.*
       native
       {
             return SongList.getSizeOfList();   
       } 
    $endif
    return 1;
  }

  // Data retrieval
  note group Note2
  {
    attr Bounds = <1149,10,1399,231>;
  }

  // Initialization
  note group Note3
  {
    attr Bounds = <10,150,250,259>;
  }

  // Properties
  note group Note4
  {
    attr Bounds = <270,0,1069,579>;
  }

  // Manipulation methods
  note group Note5
  {
    attr Bounds = <10,270,250,490>;
  }

  // Time formatting
  note group Note6
  {
    attr Bounds = <10,500,250,590>;
  }
}

$rect <-288,150,-88,190>
autoobject Application::DeviceClass Device;

$rect <760,219,960,259>
$output false
enum State
{
  // Equivalent of Ready
  $rect <10,60,210,100>
  item CanPlay;

  $rect <10,10,210,50>
  item Playing;

  $rect <220,10,420,50>
  item Paused;

  $rect <440,10,640,50>
  item Error;

  // In a sense, a particular case of Paused. It depends on the implementation. It \
  // might prove useless.
  $rect <220,60,420,100>
  item Ended;
}

$rect <339,-70,539,-30>
$output false
resource Resources::Bitmap PlayIcon
{
  attr bitmapfile FileName = .\Images and Icons\play.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <360,259,600,299>
$output false
autoobject WidgetSet::PushButtonConfig PushButtonConfig
{
  preset PressedFeedbackDuration = 50;
  preset IconTintActive = #4DFF59FF;
  preset IconTintFocused = #353535FF;
  preset IconTintDisabled = #D6D6D6FF;
  preset IconTintDefault = #3D42FFFF;
  preset LabelFont = Application::TimeFont;
  preset FaceTintActive = #06FF4CFF;
  preset FaceTintFocused = #E252FFFF;
  preset FaceTintDefault = #FFAD33FF;
  preset FaceFrameActive = 0;
  preset FaceFrameFocused = 0;
  preset FaceFrameDefault = 0;
  preset FaceActive = Application::PlayIcon;
  preset FaceFocused = Application::PausePressedIcon;
  preset FaceDefault = Application::PausePressedIcon;
}

$rect <339,-30,539,10>
$output false
resource Resources::Bitmap PauseIcon
{
  attr bitmapfile FileName = .\Images and Icons\pauseVariant.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <339,10,539,50>
$output false
resource Resources::Bitmap LoopIcon
{
  attr bitmapfile FileName = .\Images and Icons\loopVariant.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <559,-30,759,10>
$output false
resource Resources::Bitmap PausePressedIcon
{
  attr bitmapfile FileName = .\Images and Icons\pauseVariant_pressed.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <559,-70,759,-30>
$output false
resource Resources::Bitmap PlayPressedIcon
{
  attr bitmapfile FileName = .\Images and Icons\play_pressed.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <559,10,759,50>
$output false
resource Resources::Bitmap LoopPressedIcon
{
  attr bitmapfile FileName = .\Images and Icons\loop_pressed.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-70,40,130,80>
$output false
class VinylView : Core::Group
{
  $rect <530,0,730,40>
  inherited property Bounds = <0,0,464,355>;

  $rect <-10,419,190,459>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-10,379,190,419>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::WarpImage Vinyl
  {
    preset Point4 = <133,299>;
    preset Point3 = <347,302>;
    preset Point2 = <346,77>;
    preset Point1 = <133,77>;
    preset SourceAnchor = <125,125>;
    preset Bitmap = Application::GenericVinyl;
  }

  $rect <979,110,1179,150>
  method void Rotate()
  {
    var point desPos=Bounds.orect.center;
    Vinyl.RotateAndScale( desPos, -Angle, 0.9, 0.9);



  }

  $rect <539,190,739,230>
  property float Angle = 0;

  $rect <539,230,739,270>
  onset Angle
  {
    // The value doesn't change - nothing to do.
    if ( pure Angle == value )
      return;

    // Remember the property's new value.
    pure Angle = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <539,270,739,310>
  onget Angle
  {
    return pure Angle;
  }

  $rect <539,310,739,350>
  method void UpdateAngle( arg float aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Angle )
    {
      // Remember the new value in the internal memory of the property.
      pure Angle = aNewValue;


      // Notify all associated property observers.
      notifyobservers ^Angle;
    }
  }

  $rect <749,110,950,150>
  slot OnAngleEffect
  {
    UpdateAngle(AngleEffect.Value);   
    Rotate();

  }

  $rect <539,110,739,150>
  object Effects::FloatEffect AngleEffect
  {
    preset OnAnimate = OnAngleEffect;
    preset CycleDuration = 7000;
    preset Value2 = 359;
  }
}

$rect <-70,-10,130,30>
$output false
class QueueItem : Core::Group
{
  $rect <840,0,1040,40>
  inherited property Bounds = <5,0,790,50>;

  $rect <-10,270,190,310>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-10,230,190,270>
  inherited method UpdateViewState()
  {
    super( aState );


    if ( aState.contains( Core::ViewState[ Selected ]))
        Rectangle.Color=#6C789FFB;
    else
         Rectangle.Color=#909B9FFB;
  }

  // The class implements a GUI component for displaying the title and the artist \
  // of an audiotrack
  note legend Note1
  {
    attr Bounds = <219,230,920,299>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToTop];
    preset Bounds = <0,-5,791,49>;
    preset ColorBL = #CDCDCDFF;
    preset ColorBR = #CDCDCDFF;
    preset Color = #909B9FFB;
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Bounds = <26,-1,523,49>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Acid Rain";
    preset Font = Application::Font;
  }

  $rect <20,20,160,60>
  object Views::Text Artist
  {
    preset Bounds = <446,0,783,49>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Liquid Tension Experiment";
    preset Font = Resources::FontSmall;
  }

  $rect <-10,70,190,110>
  property string SongTitle = "Title";

  $rect <-10,110,190,150>
  onset SongTitle
  {
    // The value doesn't change - nothing to do.
    if ( pure SongTitle == value )
      return;

    // Remember the property's new value.
    pure SongTitle = value;
    Title.String=value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <-10,150,190,190>
  onget SongTitle
  {
    return pure SongTitle;
  }

  $rect <290,70,490,110>
  property string SongArtist = "Artist";

  $rect <290,110,490,150>
  onset SongArtist
  {
    // The value doesn't change - nothing to do.
    if ( pure SongArtist == value )
      return;

    // Remember the property's new value.
    pure SongArtist = value;
    Artist.String=value;


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <290,150,490,190>
  onget SongArtist
  {
    return pure SongArtist;
  }

  $rect <580,70,780,110>
  property string Source;

  $rect <580,110,780,150>
  onset Source
  {
    // The value doesn't change - nothing to do.
    if ( pure Source == value )
      return;

    // Remember the property's new value.
    pure Source = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <580,150,780,190>
  onget Source
  {
    return pure Source;
  }
}

$rect <339,50,539,90>
$output false
resource Resources::Bitmap PreviousIcon
{
  attr bitmapfile FileName = .\Images and Icons\previous.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <339,90,539,130>
$output false
resource Resources::Bitmap NextIcon
{
  attr bitmapfile FileName = .\Images and Icons\next.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <559,50,759,90>
$output false
resource Resources::Bitmap PreviousPressedIcon
{
  attr bitmapfile FileName = .\Images and Icons\previous_pressed.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <559,90,759,130>
$output false
resource Resources::Bitmap NextPressedIcon
{
  attr bitmapfile FileName = .\Images and Icons\next_pressed.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <778,50,978,90>
$output false
resource Resources::Bitmap PreviousDisabledIcon
{
  attr bitmapfile FileName = .\Images and Icons\previous_disabled.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <778,90,978,130>
$output false
resource Resources::Bitmap NextDisabledIcon
{
  attr bitmapfile FileName = .\Images and Icons\next_disabled.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Resources
note group Note
{
  attr Bounds = <318,-240,1019,150>;
}

// Application class
note group Note1
{
  attr Bounds = <-299,-230,0,-120>;
}

// Pannels and item views
note group Note2
{
  attr Bounds = <-299,-110,150,90>;
}

// Device
note group Note3
{
  attr Bounds = <-299,110,161,219>;
}

// GUI widgets configuration
note group Note4
{
  attr Bounds = <320,170,670,320>;
}

// Enums
note group Note5
{
  attr Bounds = <710,170,1019,320>;
}
